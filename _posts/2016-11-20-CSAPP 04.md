---
layout: post
title: CSAPP笔记（四） 处理器体系结构
categories: note
excerpt: 笔记内容只能保证我看的懂，请不要查看
tags: 计算机
---

[深入理解计算机系统](//book.douban.com/subject/5333562/)

## Y86  
[Y86介绍](http://cs.slu.edu/~fritts/CSCI224_S12/schedule/chap4-intro-Y86.pdf)
[IA32的push和pull](/note/csapp-4.6)  

## 电路逻辑  

![寄存器操作]({{ site.storage }}/assets/dist/img/2016-11-23 16-42-40屏幕截图.png)  
可以把上图长方形看成寄存器的一个**单元**，Y看成是数据输入，X是输出，时钟信号控制读写。当时钟信号是上升沿时，“写”有效，否则即为“读”  

![寄存器文件]({{ site.storage }}/assets/dist/img/2016-11-23 16-49-29屏幕截图.png)
上图为一个寄存器文件,valA和valB相当于X，valW相当于Y，时钟控制读写。src和dst表示地址，分别决定读和写的目标单元。  

显然，读无需Y，写无需X。当对同一单元同时读写时，X是会从旧值变新值。  

## SEQ  
Sequential (顺序执行)
![SEQ]({{ site.storage }}/assets/dist/img/2016-11-25 16-37-57屏幕截图.png)
SEQ的实现包括  
- 组合逻辑  
- **时钟寄存器**:PC,CC  
- 随机访问存储器:**寄存器文件**（esp,eax等），指令存储器，**数据存储器**  
加粗表示需要时钟信号，如上面[电路逻辑](#电路逻辑)中提到的寄存器文件   

下面以push为例说明SEQ  
![PUSH]({{ site.storage }}/assets/dist/img/2016-11-25 16-42-12屏幕截图.png)
Fetch 指令存储器只读，取指无需一个时钟周期    
Decode 译码没涉及到**寄存器文件**的写，故无需一个时钟周期  
Execute 执行减4也无需一个时钟周期，但进行整数运算会涉及**CC**的写，这需要一个时钟周期。  
Memory 访存**数据存储器**需要一个时钟周期  
Write back写回**寄存器文件**需要一个时钟周期,可与Memory共用一个时钟周期  
PC update 更新PC要一个时钟周期  


在[Y86](#Y86)中提到push的esp是先把数入栈，后esp - -  
若先- -后入栈  
上面SEQ应该是  
Fetch  
Decode  
Execute -4
**Write back    
Memory**  
PC update  
因为正常情况下，Memory的data到位了，然后address出来后就与Write back同时执行。  
而若要写入esp减后数则data要等Write back后才能到位，不能同时执行。  
这也违背  
**The processor never needs to read back the state updated by an instruction in
order to complete the processing of this instruction.**  
就是说状态更新后不能再读  

为什么valE只给address不给data？我觉得地址偏移用的比较多，而把运算结果写入内存用的更少。  
而更新后不读，我想是为了指令流水。  

### 取指  
![取指]({{ site.storage }}/assets/dist/img/2016-11-26 14-18-24屏幕截图.png)
instr_valid 指令合法 = icode in {}  
need_regids 需要寄存器 = icode in {}  
need_valC   包含常数 = icode in {}
