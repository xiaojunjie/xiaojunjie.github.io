---
layout: post
title: CSAPP笔记（四） 处理器体系结构
categories: note
excerpt: 笔记内容只能保证我看的懂，请不要查看
tags: 计算机
---

[深入理解计算机系统](//book.douban.com/subject/5333562/)

## Y86  
[Y86介绍](http://cs.slu.edu/~fritts/CSCI224_S12/schedule/chap4-intro-Y86.pdf)
[IA32的push和pull](/note/csapp-4.6)  

## 电路逻辑  

![寄存器操作]({{ site.storage }}/assets/dist/img/2016-11-23 16-42-40屏幕截图.png)  
可以把上图长方形看成寄存器的一个**单元**，Y看成是数据输入，X是输出，时钟信号控制读写。当时钟信号是上升沿时，“写”有效，否则即为“读”  

![寄存器文件]({{ site.storage }}/assets/dist/img/2016-11-23 16-49-29屏幕截图.png)
上图为一个寄存器文件,valA和valB相当于X，valW相当于Y，时钟控制读写。src和dst表示地址，分别决定读和写的目标单元。  

显然，读无需Y，写无需X。当对同一单元同时读写时，X是会从旧值变新值。  

## SEQ  
Sequential (顺序执行)  
![SEQ]({{ site.storage }}/assets/dist/img/2016-11-25 16-37-57屏幕截图.png)  
SEQ的实现包括  
- 组合逻辑  
- **时钟寄存器**:PC,CC  
- 随机访问存储器:**寄存器文件**（esp,eax等），指令存储器，**数据存储器**  
加粗表示需要时钟信号，如上面[电路逻辑](#电路逻辑)中提到的寄存器文件   

下面以push为例说明SEQ  
![PUSH]({{ site.storage }}/assets/dist/img/2016-11-25 16-42-12屏幕截图.png)  
Fetch 指令存储器只读，取指无需一个时钟周期    
Decode 译码没涉及到**寄存器文件**的写，故无需一个时钟周期  
Execute 执行减4也无需一个时钟周期，但进行整数运算会涉及**CC**的写，这需要一个时钟周期。  
Memory 访存**数据存储器**需要一个时钟周期  
Write back写回**寄存器文件**需要一个时钟周期,可与Memory共用一个时钟周期  
PC update 更新PC要一个时钟周期  


在[Y86](#Y86)中提到push的esp是先把数入栈，后esp - -  
若先- -后入栈  
上面SEQ应该是  
Fetch  
Decode  
Execute -4
**Write back    
Memory**  
PC update  
因为正常情况下，Memory的data到位了，然后address出来后就与Write back同时执行。  
而若要写入esp减后数则data要等Write back后才能到位，不能同时执行。  
这也违背  
**The processor never needs to read back the state updated by an instruction in
order to complete the processing of this instruction.**  
就是说状态更新后不能再读  

为什么valE只给address不给data？我觉得地址偏移用的比较多，而把运算结果写入内存用的更少。  
而更新后不读，我想是为了指令流水。  

### 取指  
![取指]({{ site.storage }}/assets/dist/img/2016-11-26 14-18-24屏幕截图.png)  
instr_valid 指令合法 = icode in {}  
need_regids 需要寄存器 = icode in {}  
need_valC   包含常数 = icode in {}  

### 译码  
![译码]({{ site.storage }}/assets/dist/img/2016-11-26 14-42-32屏幕截图.png)  
两读两写
{% highlight Python %}
int srcA = [
    icode in { IRRMOVL, IRMMOVL, IOPL, IPUSHL  } : rA;
    icode in { IPOPL, IRET } : RESP;
    1 : RNONE; # Don’t need register
];
int srcB = [
    icode in { IOPL, IRMMOVL, IMRMOVL } : rB;
    icode in { IPUSHL, IPOPL, ICALL, IRET } : RESP;
    1 : RNONE; # Don’t need register
];
int dstE = [
    icode in { IRRMOVL } : rB;
    icode in { IIRMOVL, IOPL} : rB;
    icode in { IPUSHL, IPOPL, ICALL, IRET } : RESP;
    1 : RNONE; # Don’t write any register
];
int dstM = [
    icode in { IMRMOVL, IPOPL } : rA;
    1 : RNONE; # Don’t write any register
];
{% endhighlight %}  
push时要提供address和data，故AB都得用上，  
pop是只要address，但为了保持队列，A也给address  
E是ALU后write back时的目标，比如esp+4  
M是访存后write back时的目标  
可以看出寄存器间的mov是通过ALU来来实现的  

pop %esp需要E和M，且译码时就定了。因为访存为组合逻辑，不需时钟周期，  
故valE和valM可看成同时到位，故M优先级应高于E  

### 执行  
![执行]({{ site.storage }}/assets/dist/img/2016-11-26 15-55-23屏幕截图.png)  
{% highlight Python %}
int aluA = [
    icode in { IRRMOVL, IOPL } : valA;
    icode in { IIRMOVL, IRMMOVL, IMRMOVL } : valC;
    icode in { ICALL, IPUSHL } : -4;
    icode in { IRET, IPOPL } : 4;
    # Other instructions don’t need ALU
];
int aluB = [
    icode in { IRMMOVL, IMRMOVL, IOPL, ICALL, IPUSHL, IRET, IPOPL } : valB;
    icode in { IRRMOVL, IIRMOVL } : 0;
    # Other instructions don’t need ALU
];
int alufun = [
    icode == IOPL : ifun;
    1 : ALUADD;
];
bool set_cc = icode in { IOPL };
{% endhighlight %}  

### 访存  
![访存]({{ site.storage }}/assets/dist/img/2016-11-26 16-35-12屏幕截图.png)  
{% highlight Python %}
int mem_addr = [
    icode in { IRMMOVL, IPUSHL, ICALL, IMRMOVL } : valE;
    icode in { IPOPL, IRET } : valA;
    # Other instructions don’t need address
];
int mem_data = [
    # Value from register
    icode in { IRMMOVL, IPUSHL } : valA;
    # Return PC
    icode == ICALL : valP;
    # Default: Don’t write anything
];
bool mem_read  = icode in { IMRMOVL, IPOPL, IRET };
bool mem_write = icode in { IRMMOVL, IPUSHL, ICALL };

int Stat = [
    imem_error || dmem_error : SADR;
    !instr_valid: SINS;
    icode == IHALT : SHLT;
    1 : SAOK;
];
{% endhighlight %}  

### 更新PC  
![更新PC]({{ site.storage }}/assets/dist/img/2016-11-26 16-54-28屏幕截图.png)  
{% highlight Python %}
int new_pc = [
    # Call. Use instruction constant
    icode == ICALL : valC;
    # Taken branch. Use instruction constant
    icode == IJXX && Cnd : valC;
    # Completion of RET instruction. Use value from stack
    icode == IRET : valM;
    # Default: Use incremented PC
    1 : valP;
];
{% endhighlight %}  

### 常用指令  
![常用指令]({{ site.storage }}/assets/dist/img/csapp 4-18.png)  

![常用指令]({{ site.storage }}/assets/dist/img/csapp 4-19.png)  

![常用指令]({{ site.storage }}/assets/dist/img/csapp 4-20.png)  

![常用指令]({{ site.storage }}/assets/dist/img/csapp 4-21.png)

## 流水线  
