---
layout: post
title: Tiny Web Server
categories: note
excerpt: Homework of CSAPP  
tags: 计算机
---
[深入理解计算机系统](//csapp.cs.cmu.edu/){:target="csapp"}   

## 前言  
   首先感谢谢《深入理解计算机系统》这本书让我学会了很多，读这本书的过程中总有些时刻感觉自己好像真的对计算机有了更深的理解，也许是错觉，但总是会很开心。没想到当年淘宝20包邮买的书，吃灰3年，快毕业时被我挖出来，却对我产生了深远影响。相见恨晚，后悔不已。其次，对作者深表歉意，支持正版！  
   书中作者已经实现了一个简单的[Tiny Web Server](//csapp.cs.cmu.edu/public/ics2/code/netp/tiny/tiny.c){:target="tiny"}，代码很值得一读。不过这个demo不能满足并发要求，我因此对其做了改进，造些轮子，复习下一些计算机基础。[源码](https://github.com/xiaojunjie/tiny)待完善    

## 架构    
  了解过网络编程的人都知道，server大概思路是listen在某个端口，调用accept等待客户的connect，等客户连接上时accept会返回一个fd，然后read(fd)，根据读出来的内容进行相应的处理，最后得到结果，通过write(fd)返回给客户。  

### 线程池       
假如有两个用户同时发来请求，如果server只有单线程，只能一个一个处理。
所以必须有专门的线程负责处理，专门的线程负责listen。我这里引入了线程池来负责处理。 
主线程只负责接待客户，把返回的fd放到一个容器中，线程池中的每个线程不断地从这个容器中取fd，然后read(fd),write(fd)，接着再取fd，重复...
想到这里，我突然感觉这很像那什么。古时候，在那什么店门口，总有人在门口拉客（listen），但她也只负责拉客。把客人拉进去后由服务员接待。但客人几个小时后可能就走了，所以服务员要接着接待下一位，这样才不浪费资源。  
这也是引入线程池的原因，如果对每个fd都新建线程就比较浪费。

### 路由器   
线程接过fd后，read(fd)得到内容，需要把内容扔到解析器中。
解析器根据Http协议进行解析，返回一个HttpRequest对象。HttpRequest再扔给路由器，得到HttpResponse对象，最后HttpResponse再扔给底层，活就干完了，等下一个fd。
当然，路由器得提前设定好匹配规则，比如url地址，POST还是GET，请求参数等等，还有构造HttpResponse的callback。还可以对路由表做相应的优化，比如按访问量排序  
    
### 日志  
正常的服务器总需要日志，但多线程下对同一文件读写就涉及到线程安全。日志文件不能同时被多个线程写，否则内容就乱了。如果同步写入日志，你前面有人排队的话就必须等别人写完了才能轮到你，肯定会影响性能。所以你得把要写的内容扔给一个人，扔完就跑，继续执行下一步。那人收到内容后，不能马上写入文件，否则在写期间谁来负责收，所以得有另一个人负责写。  

## 问题  

### 线程池  
- 多线程抢同一个fd怎么解决？  
[semaphores](http://pubs.opengroup.org/onlinepubs/7908799/xsh/semaphore.h.html)  
- 线程池数量怎么确定？  
在把fd推入容器时判断其余量，然后决定增删线程。  
- 如何删线程？  
往容器推入-1，正常fd都大于0，线程拿到-1就退出  

### 路由  
- 路由表的线程安全？  
多线程可能同时读表中同一项，然后对该项计数变量+1，需要对计数变量上锁，不要把整个表都锁了。  
一旦有表中有项目被命中，表的计数变量+1，上锁禁止排序，等匹配完后准备return时，表的计数-1, 如果表的计数等于0，解锁，允许排序。其实就是多读一写，读优先。 
- 什么时候排序？  
可以根据fd容器数量来决定

## 不足   
- 无法满足HTTP 1.1的长连接，需要从底层改进，利用epoll  
- 多线程干涉到路由器的计数，读写耦合，资源调各种上锁坏性能。可以仿日志的思路去设计路由器，待研究。  
- 对HttpResponse的模板渲染未完善，这涉及到业务细节，本不该由我完成，只是需要留下抽象接口给开发人员  
