---
title: 数据结构
layout: cs
---

## 树  
一棵含有n个节点的红黑树的高度至多为2log(n+1)
如果一个节点是红色的，则它的子节点必须是黑色的
m个节点的树有m-1条边，即有m-1个非空指针，所有空指针的个数为3*m-(m-1)=2*m-1
0度比全度的小1
hash
最简单的情况下，key为int，表跟数组没区别。
当key为char时，需要转为int,
int f(char){}为hash函数
哈希表(存储key)
0 a
1 b
2 ...
val存储空间
0 v0
1 v1
2 v2
data[a] = v0
hash函数：除留余数法，字符求和再取模，折叠法...
去冲突：线性探测再散列（找隔壁），链地址法（遍历琏找key），再HASH（换另一个）


位运算
DP
贪心
find
sort
queue
B树，B+树
邻接矩阵，n个结点，矩阵n*n
邻接琏表，n个结点，n条琏，该结点的邻结点相连
十字琏表，结点和弧，结点有两个指针指向in/out弧，弧有head/tail结点和两个指针，分别指向head/tail相同的弧，
最小生成树,路径权和最小的子图，prim算法O(V^2)适合边密的，Kruskal算法O(eloge)边稀


堆排序
先层次遍历建立树，后从右下角调整

哈夫曼树
从下往上建，取两个最小，0左1右

红黑树(BST升级版)
根结点 叶结点（NULL）黑色
任一结点到叶结点遇到的黑色相同

RBT优点：
相对AVL对平衡要求低，所以旋转次数少
相对BST最长路径不大于两倍的最短路径的长度
数据比较乱是用红黑树，数据分布比较好用AVL
数据比较死就有hash,红黑树适合比较活的

B+树优于红黑树
1. O(lognN) 出度大于2
2. 叶子结点顺序预读，空间局部性原理
